
#Основы Python.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Kmwj6o4O_G6JbfsLtZiqDvCz2gpNs3Lg

Google colab - это удобный инструмент для анализа данных
```
py

first_name = input("Enter your first name:")
last_name = input("Enter your last name:")
age = input("Enter your age:")
city = input("Enter your city of residence:")

print("")
print("Hello,", first_name, last_name, "!")
print("")
print("Your profile:")
print("Age:", age, "years")
print("City:", city)

cur_date = input('Enter date: ')
currency = input('Enter currency: ')
rate = 86.37
print(f'The {currency} currency rate on the date {cur_date} is {rate}')

name = "John"
dayofweek = "Friday"
print(f"Hello, {name}! Today is {dayofweek}. Have a nice day!") # использовали f строку для упрощения

name = "John"
dayofweek = "Friday"
print("Hello, {}! Today is {}. Have a nice day!" .format(name,dayofweek))

a = int(input()) # Мы можем преобразовать результ.работы функции input() в тип данных int,  применив к результату встроенную в Python функцию int():
print(a + 10)

b = float('125.13') # Аналогично, можно преобразовывать строки в тип данных float,
c = 18.9
print(b + c)

d = 12942021.24910 # Мы преобразовали число в тип данных str и применили метод split(), указав в качестве разделителя '.'.
d_str = str(d)
print(d_str.split('.'))

advertisement = 'Refrigerator service life: 9 years 3 months'
advertisement_splited = advertisement.split() # разделили строку на слова c помощью метода split():
year = advertisement_splited[3] # Далее извлечём количество лет и месяцев службы. Jбратимся к результирующему списку advertisement_splited по индексам 3 и 5:
month = advertisement_splited[5]
service_life = int(year) * 12 + int(month) # чтобы получить срок службы холодильника в месяцах, остаётся только умножить значение переменной year на 12 и сложить результат со значением переменной month.
print(service_life)

salary = "128500 руб."
salary_split = salary.split() # разделили строку на слова c помощью метода split():
a = salary_split [0] # извлекли строку 128500
b = salary_split [1] # извлекли строку руб.
salary_number = int(salary_split [0]) / 1000 # преобразоваи из строку 128500 в числовые данные
print(salary_number, b)

experience = "Work experience 202 months"
experience_split = experience.split() # разделили строку на слова c помощью метода split():
month = experience_split[2] # извлекли строку
experience_year = int(month) // 12
experience_month = int(month) % 12
print(f"Experience_year = {experience_year:.0f}, Experience_month = {experience_month:.0f}")

description = "Male , 38 years old , born on June 25 , 1980"
description_split = description.split() # разделили строку на слова c помощью метода split():
a = description_split[0] # извлекли строку Male
gender = a.lower() # строку Male подогнали в нижний регистр
age = description_split[2] # извлекли строку 38
year_of_birth = description_split[11] # извлекли строку 1980
print("gender = {}, age = {}, year of birth = {}".format(gender,age,year_of_birth))

description = "Male,38 years old,born on June 25,1980"
description_split = description.split(",") # ['Male ', ' 38 years old ', ' born on June 25 ', ' 1980']
gender = description_split[0].lower() # извлекли строку Male + # строку Male подогнали в нижний регистр
age = description_split[1].split(" ")[0] # извлекли строку 38
year_of_birth = description_split[3] # извлекли строку 1980
print("gender = {}, age = {:0}, year of birth = {}".format(gender,age,year_of_birth))

b = list(range(50,20,-2)) # создаем список: 50 левая граница, 20 правая граница, -2 это шаг
print(b)

a = list(range(1, 11)) #Создали список "a" из чисел от 1 до 10 (включительно)
a_slice = a[0:2] # сделали срез из двух первых элементов
print(a_slice)

a = list(range(-5, 6)) #Создали список "a" из чисел от -5 до 5 (включительно)
a_slice = a[4:9] # сделали срез чтобы в ответете был следующий список: [-1, 0, 1, 2, 3]
print(a_slice)

a = list(range(-3, 7)) #Создали список "a" из чисел от -3 до 6 (включительно)
a_slice = a[::-1] # инвертируйте список в обратном направлении
print(a_slice)

a = "hello kitty"
a_split = a.split() # С помощью функции .split() получиЛИ список из строки
print(a_split[-2:]) # взяли два последних элемента

a = "order1" # создали переменные
b = "order2"
c = "order3"
orders=[] # создали пустой список
orders.append(a) # последовательно вложили в список переменные
orders.append(b) #
orders.append(c) #
print(orders) # вывели список

letters=["a", "b", "c", "d", "e"] # создали список
print(letters) # вывели список
letters.clear() # очистели список
print(letters) # вывели очищенный список

numbers=[1,5,"c","d",5,1,18,11,4,3,5,1] # создали список
print(numbers.count(5)) # вывели количество цифр 5 в списке

my_books=['book1', 'book2', 'book3', 'book4', 'book5'] # создали список
tom_books=my_books.copy() # скопировали список 1 в список 2
print(my_books,tom_books) #вывели два списка

my_orders=['order1', 'order2', 'order3', 'order4', 'order5'] # создали список
anne_orders=my_orders[:] # другим методом скопировали список 1 в список 2 (синтаксический сахар для данного метода копирования)
print(my_orders, anne_orders) #вывели два списка

all_things=['order1', 'order2', 'order3'] # создали список 1
only_books=['book1', 'book2'] # создали список 2
all_things.extend(only_books) # обогатили список 1 списком 2
print(all_things)

nums=[1,2,3,4,5,6,7,8,9,10] # создали список
nums.reverse() # реверс (переворачивание)
print(nums)

random_values = [3, 5, 0, -1, 2, 10, 15, -5] # создали список
random_values.sort() # отсортировали
print(random_values)

list1=[5, 0.2, 'hello there', [1,2,3,4], 'bye'] # создали список из чисел и строк
print(list1) # можно d список вставлять числа 1,2 списки [1,2], кортежи (1,2), число с плавающей точкой в виде строки "5.1, 5.2"

tpl3=(15,22,0) # создали картеж (он не изменяемый)
print(tpl3) #вывели

place_and_money = {1: 100, 2: 50, 3: 10} # Создали словарь
place_and_money[4] = 5 # дополнили словарь новыми данными
place_and_money[3] = 25 # измените значение для третьего места с 10 на 25
print(place_and_money[2]) # вывели значение по второму месту через ключ 2

target_string= 'кота тащат в шалаш'
target_string = target_string.lower().replace(' ', '')# Приводим строку к нижнему регистру и заменяем пробелы на пустые строки
result = target_string == target_string[::-1]# Сравниваем преобразованную строку с ней же в развернутом варианте
print("Result", "=", result)

diagnosis_1='no' # симптомы заболевания 1
diagnosis_2='no'# симптомы заболевания 2
diagnosis_3='yes'# симптомы заболевания 3
a= diagnosis_1 in "yes" # если да
b= diagnosis_2 in "yes" # если да
c= diagnosis_3 in "yes" # если да
result= a or b or c # есть ли симптомы хотябы одного из 3 заболеваний)
print(result)

orders = {'2022-10-10': ['F124', 'D89D', '142L'],
    '2022-10-11': ['H241', 'OR24', 'BE14', '348F'],
    '2022-10-12': ['H429', 'JAS2']}
#адан словарь покупок за период с 10 по 12 октября 2022 года.
target_order = 'BE14'
# Необходимо узнать, поступал ли за указанный период заказ с идентификатором 'BE14'.
result = (target_order in orders['2022-10-10']) or \
         (target_order in orders['2022-10-11']) or \
         (target_order in orders['2022-10-12'])
# Проверяем вхождение строку target_order в списки, хранящийся по имеющимся ключам
# через логическим "ИЛИ" — оператором or.
print(result)

message = 14093530013530593
# Представим, что мы обмениваемся секретными сообщениями, составленными только из определённых
# слов. Каждое из ключевых слов в сообщении кодируется одним или несколькими числами.
# Известно, что «шумовое» сообщение отличается от обычного тем, что в нём в первых шести цифрах обязательно должна содержаться цифра 5.
message_is_useful = '5' not in str(message)[:6]
# Проверяем вхождение символа '5' в первые 6 символов строки
# для этого превратили цифру 5 в символ строки "5", а длинное число превратили в строку функции str
# и взяли у него срез первых 5 символов через [:6]
print(message_is_useful)
# по условию от нас требуется обратное, поэтому не забудем добавить оператор отрицания not перед in:

# Шахматная фигура передвигается по доске 8x8 клеток. Нумерация клеток по горизонтальной ведётся с помощью первых 8 латинских букв, а по вертикальной — с помощью цифр от 1 до 8.
# Координатам по горизонтальной и вертикальной осям шахматной доски, в которые должна переместиться фигура, соответствуют переменные x и y:
x = "F" # ход по горизонтали в виде строки
y =  7 # ход по вертикали в виде числа
gorizontal="abcdefj" # клетки по горизонтали доски задали в строку "abcdefj"
vertikal="12345678" # клетки по вертикали тоже задали в строку "12345678"
gorizontal_up=gorizontal.upper() # привели строку к верхнему регитсру
move_is_correct= x in gorizontal_up and str(y) in vertikal # сохранили в переменную move_is_correct
# условия при котором ход по оси X должен входить в строку gorizontal_up а ход по Y в строку vertikal
print(move_is_correct)

# В одной упаковке содержится 13 карандашей. Количество упаковок в наличии на складе = available_packages.
# Количество произведённых карандашей хранится в переменной total_count.
available_packages = 105 # есть на складе упаковок
total_count = 1677 # всего произведено карандашей
# Проверяем, что все карандаши удастся распределить по упаковкам (13 карандашей в упаковке)
condition_1 = total_count % 13 == 0 # % это фунция деления без остатка и через оператор сравнения сравниваем с нулем
# Проверяем, достаточно ли у нас упаковок на складе
condition_2 = total_count // 13 <= available_packages # // - оператор целочисленного деления где
# мы всего карандашей делим на 13 (целочисленно) и д.б. меньше ли равно в наличии на складе упаковок
result = condition_1 and condition_2
# По условию задачи условия должны выполняться одновременно, поэтому объединим их с помощью оператора and, а результат занесём в переменную result:
print(result)

N = 45901
simbol = str(N)[0] # перевели число в строку и взяли из него 1 символ
simbol_int= int(simbol) # преобразовали строку 45901 в через функий инт в целочисленное
first_is_even= simbol_int % 2 == 0 # узнали делится ли взятый ПЕРВЫЙ символ (4) на 2 без остатка
print(first_is_even)

year = 1900 # надо узнать является ли наш год високосным
a= (year % 400 == 0) # 1 условие год должен делиться без остатка на 400
b= (year % 4 == 0) and\
 (not year / 100) # условиче 2 : нужно чтобы год делился без остатка на 4 и одновременно не делился на 100
year_is_leap= (a or b) # должно выполняться одно из словий 1 или 2
print(year_is_leap)

# Информация о количестве долек в ширину и длину шоколадки, а также количество долек, которое должно получиться после разделения, содержится в переменных n, m и k соответственно.
n, m, k = 5, 4, 25
delen= (k % n == 0) or (k % m == 0) # Для того, чтобы шоколадку можно было разделить на 2 части по горизонтали или вертикали необходимо, чтобы количество долек, которые мы хотим получить k, нацело делилось либо на ширину шоколадки, либо на ее длину (в дольках).
kolvo=   k <= (n*m) # Также необходимо учесть, что количество долек, которые мы хотим получить должно быть меньше либо равно площади всей шоколадки.
result= delen and kolvo # необходимо чтобы выполнялись все 2 услович описанные выше
print(result)

phone = '+7 927 124 42 12'
phone_is_defined= phone is not None # узнаем, в переменной phone есть или нет записи через проверку на None (отсутствие)
print(phone_is_defined)
# phone_is_defined = True # если запись есть значит должно быть правдой поэтому и сделали через отрицание not

phone = None
phone_is_defined= phone is not None
print(phone_is_defined)
# phone_is_defined = False # если запись есть значит должно быть ложью

# Имеется информация о приходах товара на склад интернет-магазина. Ключами этого словаря являются номера накладных,
# а значениями — словари, в которых содержится информация о товаре и его количестве в каждой из накладной.
arrival_of_goods = {
    '148902': {
        'Футболка с принтом': 180,
        'Свитшот черный': 245,
        'Джинсы серые': 252
    },
    '893516': {
        'Футболка с принтом': 43,
        'Свитшот черный': 64,
        'Джинсы черные': 102
    },
    '893481': {
        'Кружка керамическая': 35,
        'Свитшот черный': 10,
        'Джинсы сервые': 14
    }
}
invoice_number = '148902' # содержит номер накладной, который мы хотим найти.
value = arrival_of_goods.get(invoice_number) # использовали метод словарей а затем проверили на None
invoice_exists= value is not None
print(invoice_exists)

people_count = 9  # всего людей в туалете (переменная)
# Реализуем условный оператор if-else
if people_count < 10: # поместили условие в блок if которая показывает,что сли в туалете людей меньше 10 то горит табличка Добро пожаловать!
    print("Добро пожаловать!")
else:
    print("Всё занято. Подождите!") # в противном случае должна гореть табличка "Занято!

password = '879f2aabS' # Реализуем условный оператор if-else
answer = '879f2aabS'
if password == answer:
    print("Добро пожаловать!")
else:
    print("Вы ввели неверный пароль!")

name= "Андрей" # Реализуем условный оператор if-else
age = 19
if age >= 18: #  не забывать двоеточие
    print("Добрый вечер, {}!".format(name)) # 4 пробела не забывать
else:
    print("Привет, {}! Приносим свои извинения, но вы не можете гулять после 22:00".format(name))

credit_history = 'good' #кредитная история
deposit = True # есть ли залог
guarantors = False # есть ли поручители
credit = 500.0 #сумма долга

if credit_history == 'bad':
    if deposit:
        if guarantors:
            print('Issue a loan')
        else:
            print('Not to issue a loan')
    else:
        print('Not to issue a loan')
else:
    if credit < 1000:
        print('Issue a loan')
    else:
        print('Not to issue a loan')

number= 200
# Проверяем условие: число делится на 2 без остатка
if number % 2 == 0:
    # условие выполняется
    # Проверяем условие: число делится на 5 без остатка
    if number % 5 == 0:
        #условие выполняется
        print('{} делится на 2 и на 5'.format(number))
    else:
        #условие не выполняется
        print('{} делится на 2, но не делится на 5'.format(number))
else:
    # условие выполняется
    # Проверяем условие: число делится на 5 без остатка
    if number % 5 == 0:
        # условие выполняется
        print('{} не делится на 2, но делится на 5'.format(number))
    else:
        # условие не выполняется
        print('{} не делится ни на 2, ни на 5'.format(number))

# Сначала обычный, потом Шаблон синтаксиса тернарного оператора:
a = 42
b = 41
if a > b:
    result = a
else:
    result = b
print(result)
# Шаблон синтаксиса тернарного оператора:
# variable = <значение при выполнении условия> if <условие>
# else <значение при невыполнении условия>
# следовательно можно записать подругому
result = a if a > b else b
print(result)
# он читается как:
# → Хорошо написанный код можно читать буквально.
# В данном случае строку кода можно прочитать как:
# «Присвой переменной result значение a, если a больше b, в противном случае присвой значение b».
# Просто, не правда ли?

cust_age=68
cust_discount= 20 if cust_age >= 60 else 10
# с помощью тернарного оператора записали:
# переменная cust_discount будет = 20% при усовии cust_age (возраст) больше или = 60 лет
# в противном случае скидка будет 10 %
print(cust_discount)

now = '11:24:39' # время в неастоящий момент
hour, minute, second = now.split(':') # сплитанули время, разделя на строки
hour, minute, second = int(hour), int(minute), int(second) # перевели их в числа чтобы можно было сравнивать
if (hour >= 6) and (hour < 12):
    print("Morning!")
# либо записать упрощеннее
# if 6 <= hour < 12:
#    print("Morning!")

target_word= 'quality'
if "q" in target_word:
    print("Ух ты! Вы ввели редкое слово!")
if "z"in target_word:
    print("Ух ты! Вы ввели редкое слово!")
else:
    if not "q" in target_word:
        print("Это не очень редкое слово...")

height = 188
weight = 78
zodiac_sign = 'дева'
zodiac= ["весы", "дева", "овен", "козерог"]
if height > 180 and weight < 80:
    if zodiac_sign in zodiac:
        print("Ваша половинка нашлась!")
    else:
        print("Попробуем поискать еще!")
else:
    print("Попробуем поискать еще!")

month=11
if month in [3, 4, 5]:     # весна
   print("Spring")
elif month in [6, 7, 8]:   # лето
   print("Summer")
elif month in [9, 10, 11]: # осень
   print("Autumn")
elif month in [12, 1, 2]:  # зима
   print("Winter")
else:                      # некорректный номер месяца
   print("Incorrect month number")

# Необходимо реализовать условный оператор, который печатает на экран характеристику ветра и его класс (от 1 до 4) в зависимости от его характера:
speed = 18
if speed in list(range(1, 5)):
    print("weak [1]")
elif speed in list(range(5, 11)):
    print("moderate [2]")
elif speed in list(range(11, 19)):
    print("strong [3]")
else:
    print("hurricane [4]")

# игра камень, ножницы, бумага
player_1 = 'ножницы'
player_2 = 'камень'
a_1 = player_1 == "камень" and player_2 == "ножницы" # создадим победные комбинации для игрока 1
b_2 = player_1 == "бумага" and player_2 ==  "камень"
c_3 = player_1 == "ножницы" and player_2 == "бумага"
if player_1 == player_2: # сравним 2 пеемннных если они равны - ничья
    print("Ничья!")
elif a_1 or b_2 or c_3: # потом сравним победные комбинации, если они выпадут побидитель игрок 1
    print("Первый игрок — победитель!")
else:
    print("Второй игрок — победитель!") # если нет, победитель игрок 2

dish_time_dict = {
    'Рамен с говядиной': 15,
    'Суши': 18,
    'Лагман с курицей': 20,
    'Лагман с говядиной': 24,
    'Плов с курицей': 28
} # блюда, которые в данный момент ресторан может приготовить и среднее время их приготовления (в минутах).
street_time_dict  = {
    'Дзержинский': 39,
    'Солнечный': 40,
    'Заводской': 27,
    'Гагаринский': 43,
    'Кировский': 37,
    'Октябрьский': 34
} # указаны районы города и среднее время доставки в эти районы (в минутах).
dish, street = 'Плов с курицей', 'Солнечный' # Блюдо, заказанное пользователем, и район, в котором он живёт
#Сначала мы проверим, что в указанном районе не осуществляется доставка
if street not in street_time_dict:
    print("Доставка в ваш район недоступна")
# и проверим наличие блюда в меню
elif dish not in dish_time_dict:
    print("Блюдо недоступно, закажите что-то другое")
# Теперь нам осталось внутри блока else написать условие для проверки того,
# что сумма времени приготовления указанного блюда и его доставки меньше,
# чем 60 минут. Напомним, что для обращения по ключам словаря используется операция индексации
dish_time = dish_time_dict[dish] # возьмем по отдельности время приготовления блюда
street_time = street_time_dict[street] # и время доставки
# и создадим новые переменные dish_time (время приготовления), street_time (время доставки)
# А ТАКЖЕ создаим новую переменную full_time,
# которая будет равна суммарному времени доставки с момента заказа:
full_time = dish_time + street_time  # общее время доставки
# А также выведем значение переменной delay — задержка в минутах.
# Она будет равна разнице между суммарным временем доставки (значением full_time) и 60.
delay = full_time - 60  # задержка
if delay <= 0:
    # задержка не положительна
        print("Заказ будет доставлен вовремя")
else:
    # задержка положительная
    print("Курьер задержится на {} минут".format(delay))

# cоздали словарь ошибок
errors_dict = {
    'length': 'Длина пароля не равна 8 символам',
    'digits': 'Пароль состоит только из цифр',
    'letters': 'Пароль состоит только из букв',
    'upper': 'Отсутствуют заглавные буквы',
    'lower': 'Отсутствуют строчные буквы',
    'spec': 'Отсутствуют спецсимволы в пароле',
    'bad_symbols': 'В пароле использованы непредусмотренные символы'
}
bad_symbols = ['!', '@', '$', '%', '^', '`', '&', '(', ')', '+', '=', '_', '~']
password = 'Aafaf*al'
# Проверяем длину пароля
if len(password) == 8: # разбили пароль на буквы
    errors_dict.pop('length')
# Если ограничение на длину выполняется,
# то из словаря errors_dict удаляем соответствующую ошибку ('length') через POP.
# Проверяем, что пароль НЕ состоит только из цифр
if not password.isdigit():
    errors_dict.pop('digits')

# Проверяем, что пароль НЕ состоит только из букв
if not password.isalpha(): # не состоит (через not) из букв
    errors_dict.pop('letters') # удаляем соответствующую ошибку ("letters") через POP.

# Проверяем, есть ли в пароле заглавные буквы
if password.lower() != password:
    errors_dict.pop('upper')

# Проверяем, есть ли в пароле строчные буквы
if password.upper() != password: # != символ неравенства (не совпадает)
    errors_dict.pop('lower')

# Проверяем, есть ли в пароле специальные символы
if '*' in password or '-' in password or '#' in password:
    errors_dict.pop('spec')
    # Проверяем, встречаются ли спец символы в пароле несколько раз
    if password.count('*') > 1 or password.count('-') > 1 or password.count('#') > 1:
        errors_dict['spec_count'] = 'Какой-то из спецсимволов в пароле использован более одного раза'

# Проверяем, есть ли в пароле запрещенные символы
if len(set(password).intersection(set(bad_symbols))) == 0:
    errors_dict.pop('bad_symbols')

# Проверяем результирующую длину чек-листа
if len(errors_dict) > 0:
    print(list(errors_dict.values()))
else:
    print('Пароль идеален!')

prices = {'Adidas': 4298, 'Nike': 6550, 'Puma': 4490, 'Asics': 3879} # цена для товаров бренда в виде списка
purchases = ['Nike', 'Nike'] # список товара в корзине покупателя
if len(purchases) == 0:
    print("Ваша корзина пуста")
if len(purchases) == 1:
    a = prices[purchases[0]] # достали значение по ключу (оно всего одно поэтому ставим [0])
    print('Стоимость заказа составила: {} '.format(a)) # либо print(f"Стоимость заказа составила: {a}")
elif len(purchases) == 2:
    if len(set(purchases)) == 1:
# с помощью len смотрим сколько значений, с помощью set разбиваем значение purchases на множества
# и смотрим сколько значений с одинаковым множеством, если 1 (значит приобретено 2 товара одинаковой марки)
        discont=10 # по условию скидка 10%
    else: # если значений с одинаковым множеством 2 (значит приобретено 2 разных овара)
        discont=5 # по условию скидка 5 %
# Далее достаем значение по ключам и определяем стоимость
    a = prices[purchases[0]] + prices[purchases[1]] # ранее доставали значение по 1 ключу (сейчас делаем по двум)
# Рассчитываем стоимость с учетом скидки
    discont_a= a * (1 - discont/100)
# Стоимость заказа составила: <стоимость заказа без скидки>. С учетом скидки в <размер скидки>% — <стоимость заказа со скидкой>
    print(f"Стоимость заказа составила: {a}. С учетом скидки в {discont}% — {discont_a}")

#date = '16.04.2019 15:59'
#date = '12.05.2019 08:42'
#date = '05.07.2018 20:15'
date = '30.05.2019 18:20'
category = 1
date_split = date.split() # сплитанули строку получили ['16.04.2019', '15:59']
date_split = date_split[0] # изьяли из сплита дату '16.04.2019' со значением [0]
day, month, year = date_split.split('.') # сплитанули дату по точке, разделя на строки - 16 04 2019
day, month, year = int(day), int(month), int(year)
if month == 5 and year == 2019: # берем месяц и год (если изиенения были в мае 2019 - то это первая категория)
    print(category)
elif (month >= 1) and (month >= 4) and (year == 2019): # берем месяцы с января по май 2019 (не включая) - то это категория 2)
    print(category+1)
elif year < 2019: # берем месяцы с января по май 2019 (не включая) - то это категория 3)
    print(category+2)

# аналогия выше как сделал я....Ниже как сделали учителя
date = '30.05.2019 18:20'
day_month_year = date.split(' ')[0] # Разделяем строку на части по пробелу и берем первую из них
day, month, year = day_month_year.split('.')# Разделяем строку по символу '.' и создаем соответствующие переменные
if year == "2019": # Проверяем, что резюме обновлено в 2019 году
    if month == "05":# Проверяем, что резюме обновлено в мае
        category = 1 # Присваеваем категорию 1
    else: # Присваеваем категорию 2
        category = 2
else: # Присваеваем категорию 3
    category = 3

city_info = "Москва , не готов к переезду , готов к командировкам"
#city_info = "Москва , м. Беломорская , не готов к переезду, не готов к командировкам"
#city_info = "Санкт-Петербург , готов к переезду (Сочи, Москва) , готов к командировкам"
#city_info = "Новосибирск , готов к переезду, не готов к командировкам"
million_cities = ['Новосибирск', 'Екатеринбург', 'Нижний Новгород', 'Казань', 'Челябинск', 'Омск', 'Самара', 'Ростов-на-Дону', 'Уфа', 'Красноярск', 'Пермь', 'Воронеж', 'Волгоград']
city_split = city_info.split(' , ')[0] # Разделяем строку на части по запятой  и берем первую из них
if (city_split == "Москва") or (city_split == "Санкт-Петербург"):
    city = city_split
elif city_split in  million_cities:
    city = "Город миллионник"
else:
    city = "Другое"

# Добавляем конструкцию try-except для отлова нашей ошибки
try:
    print("Before exception")
    # Теперь пользователь сам вводит числа для деления
    a = int(input("a: "))
    b = int(input("b: "))
    # Здесь может возникнуть исключение деления на ноль
    c = a / b
    # Печатаем c = a / b если всё хорошо
    print(c)
# Добавляем тип именно той ошибки которую хотим отловить.
except ZeroDivisionError as e:
    # Выводим информацию об ошибке
    print(e)
    print("After exception")

print("After after exception")

```
Примечание. В блоке except мы указали имя исключения, которое мы ожидаем — ZeroDivisionError (ошибка деления на 0). С помощью ключевого слово as мы дали этому объекту имя (по сути записали в переменную с именем e). Далее в этом же блоке мы можем воспользоваться переменной e и вывести её на экран.
В блок try помещается «опасный» кусок кода, который может вызывать исключения. А в блоке except указывается класс ошибки, которую мы хотим отловить, а затем помещается код, который нужно выполнить в случае возникновения ошибки.

В данном случае после возникновения ошибки код в блоке try прервётся, перейдёт в блок except, а затем продолжит выполняться дальше, то есть программа не вылетает, как это было без обработчика исключений. В этом и есть главная суть конструкции try-except.

Ну, конечно же, это ещё не всё. Есть также блоки finally и else. Если вы хорошо помните тему условия, то там тоже было ключевое слово else. Код в блоке else выполнялся, если не отработал ни один из блоков if-elif. С try-except происходит нечто похожее — блок else подключается тогда, когда не отработал блок except. Посмотрите на пример кода ниже.

```
py
# Добавляем конструкцию try-except для отлова нашей ошибки
try:
    print("Before exception") # Перед исключением
    # Теперь пользователь сам вводит числа для деления
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b
    # Печатаем c = a / b, если всё хорошо
    print(c)
# Добавляем тип именно той ошибки которую хотим отловить.
except ZeroDivisionError as e:
    print("After exception") # После исключения
# код в блоке else выполняется только в том случае, если код в блоке try выполнился успешно (т. е. не произошло никакого исключения)
else:
    print("Everything's fine!")# Всё отлично!
# код в блоке finally выполнится в любом случае при выходе из try-except
finally:
    print("Finally finished!") # Наконец-то завершено!

print("After After exception") # После после исключения
```

# Здесь результат работы программы будет зависеть от ввода пользователя. Если пользователь введёт всё правильно, то он должен увидеть следующее:

Before exception
*результат деления a/b*
Everything's fine!
Finally finished!
After After exception

Если же ошибка возникнет, то пользователь увидит следующее:

Before exception
After exception
Finally finished!
After After exception

То есть код в блоке else не выполнится, так как было исключение, а код в блоке finally выполнится в обоих случаях.

```
py
images_db = [101252, 521929, 215251] # у нас есть некоторый список images_db, в нём хранятся идентификаторы изображений
#gользователь вводит номер (индекс) элемента, который он хочет получить, а мы выводим на экран сам элемент.
img_id = images_db[index] # Индекс, который ввёл пользователь, находится в переменной index.
print(f'Image id: {img_id}')
```

Есть вероятность, что в переменной index содержится такое число, что при обращении к списку возникнет ошибка выхода за его пределы. Например, если значение переменной index будет равно 10, а длина списка будет равна 3, мы увидим на экране следующее:

IndexError: list index out of range
```
py
# Так как при выходе за пределы списка возникает исключение IndexError, давайте завернём код в конструкцию try-except.
index = 10
images_db = [101252, 521929, 215251]
try:
    img_id = images_db[index]
except:
    img_id = images_db[-1] # если пользователь вводит индекс, при обращении по которому мы выходим за пределы списка, в качестве id изображения выводится последний идентификатор из списка.
print(f'Image id: {img_id}')

# код
my_dict = {'a': 10, 'b': '5.214', 'c': 'simple_string'}

value_1 = my_dict[key_1] # Обращение по ключам словаря: my_dict[key_1] и my_dict[key_2]
value_2 = my_dict[key_2]
value_1, value_2 = float(value_1), float(value_2) # Явное приведение к типу данных float: float(value_1) и float(value_2)
new_value = value_1 + value_2
```

1) Начнём с обращения по ключам. Если мы попытаемся обратиться к словарю по ключу, которого не существует, получим ошибку KeyError.
2) Следующая проблема — попытка преобразования значений value_1 и value_2 к типу данных float. Попытка привести один тип данных к другому может обернуться ошибкой ValueError.

```
py

# Обезопасим нашу программу от таких ошибок.
my_dict = {'a': 10, 'b': '5.214', 'c': 'simple_string'}
try:
    value_1 = my_dict[key_1]
    value_2 = my_dict[key_2]
    value_1, value_2 = float(value_1), float(value_2)
    new_value = value_1 + value_2
except KeyError:
    print('Введен неверный ключ')
except ValueError:
    print('Неверное преобразование типов')

# !!!!!!!!!!!!!!!!!!!!!!!!! Можно и подругому
# Можно отлавливать не конкретный тип ошибки, а все виды исключений, которые могут возникнуть
# в коде. Для этого вместо конкретного типа ошибки нужно указать Exception.
try:
    value_1 = my_dict[key_1]
    value_2 = my_dict[key_2]
    value_1, value_2 = float(value_1), float(value_2)
    new_value = value_1 + value_2
except Exception as e: # код ошибки записали в переменную "e"
    print('Код завершился с ошибкой: {}'.format(e))

medicines = {'Ибупрофен': 99, 'Эспумизан': 279, 'Пенталгин': 119} # есть словарь
name = 'Визин'
# Если строка name не является ключом словаря, то на экран через print выводится сообщение «Такого ключа в словаре нет».
#medicines = {'Ибупрофен': 99, 'Эспумизан': 279, 'Пенталгин': 119}
#name = 'Ибупрофен'
try:
    result = medicines[name]
    print(result)
except Exception:
    print("Такого ключа в словаре нет")

age = int(input("How old are you?"))

# Проверяем, что возраст пользователя корректный
if age > 100 or age <= 0:
    # Намеренно вызываем ошибку, в скобках указываем текст ошибки
    raise ValueError("You are too old or don't exist")
# Возраст выводится только в том случае, если пользователь ввёл правильный возраст.
print("You are {} years old!".format(age))

```
Здесь ошибка ValueError возникнет, если пользователь ввёл неправильный возраст, и остановит работу программы, выдав в консоль:

raise ValueError("You are too old or don"t exist")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
ValueError: You are too old or don"t exist
```
py

# Стоит отметить, что отлавливать вызываемые с помощью raise ошибки тоже можно.

try:# Добавляем конструкцию try-except для отлова нашей ошибки
    age = int(input("How old are you?"))
    # Проверяем, что возраст пользователя корректный
    if age > 100 or age <= 0:
        # Намеренно вызываем ошибку, в скобках указываем текст ошибки
        raise ValueError("You are too old or don't exist")
# Ловим исключение ValueError
except ValueError:
    # В случае возникновения исключения выводим сообщение
    print("Wrong age")
# В блоке else прописываем часть, которая выполняется, если блок try отработал без ошибок
else:
    # Возраст выводится только в том случае, если пользователь ввёл правильный возраст.
    print("You are {} years old!".format(age))

```
Резюмируем:

Исключения — это ошибки, которые выбрасываются при неправильной работе программы и останавливают её выполнение, если они не обработаны.
Конструкция try-except служит для обработки исключений.

Блоки finally и else необязательны, но могут использоваться для удобства. Код из блока finally выполняется в любом случае, независимо от исхода в блоках try-except. Код из блока else выполняется только в случае успешного выполнения кода в try.
Выбрасывать ошибки можно и по своему желанию с помощью конструкции raise *Тип ошибки* (сообщение, которое нужно вывести в консоль).
```
py

number = 20
#number = 7
#number = 0
try:
    result = number / 10
    print(result)
except ZeroDivisionError:
    print("Вы собираетесь делить на 0")

number = 7
if number == 0:
        raise ZeroDivisionError ("Вы собираетесь делить на 0") # Намеренно вызываем ошибку ZeroDivisionError
else:
    result = round(10/number, 3) # с помощью функции round() округлили полученное число после деления (10/numbe) до 3 знаков.
    print(result) # если все хорошо выводим правильный ответ

# ЦИКЛЫ
 for user_id in users: #для всех пользователей
    send_message(user_id) #отправить уведомление

# Определяем итерируемый объект
my_list= [5, 9, 19]
# Подставляем его в шаблон для цикла и записываем имя переменной цикла
for element in my_list:
    # Указываем необходимые действия в тело цикла
    print('Element', element)

```
value = value + a	(value += a)

value = value - a	(value -= a)

value = value / a	(value /= a)

value = value * a	(value *= a)

value = value ** a	(value **= a)
```
py

incomes = [120, 38.5, 40.5, 80] # Дан список доходов членов семьи Быковых (в тысячах рублей).

S = 0 # Задаём начальное значение суммы доходов в переменной s
# Создаём цикл for, в котором будем проходиться по элементам списка incomes.
# income — текущее значение элемента списка
for income in incomes:
  # Выводим текущее значение переменной income
    print('Current income', income)
    # Выводим текущее значение переменной S
    print('Current S', S)
    # Увеличиваем сумму доходов на значение income
    # Равносильно S = S + income
    S += income
    # Выводим обновлённое значение переменной S
    print('New S', S)
    # Выводим пустую строку для красивого отображения
    print()
# Выводим результат
print('Answer: s=', S)

num_list = [1, 10, 0.5, 21, 0.13]
p = 1
for num in num_list:
    # умножайте значение произведения на элемент списка
    # Равносильно P = P * num
    p *= num
    print(p)
print('p =', p)

# !!!!!!!!!!!Функция range может работать тремя способами:!!!!!!!!!!!
print(list(range(5)))
# [0, 1, 2, 3, 4]
# В этом случае она принимает одну переменную STOP и возвращает последовательность элементов от 0 до STOP-1 с шагом в 1.

print(list(range(2, 5)))
# [2, 3, 4]
#В данном случае вы получите последовательность от START до STOP-1 также с шагом в 1.

print(list(range(1, 10, 2)))
# [1, 3, 5, 7, 9]
# Конструкция list(range(start, stop, step)) позволяет получить последовательность (список) целых чисел, начинающуюся со start, заканчивающуюся в stop-1 и шагом step.



```
В математике факториал числа n — это произведение чисел от 1 до n включительно. Это записывается как:

n! = 1 · 2 · 3 · ... · (n-1) · n

Например:

3! = 1 · 2 · 3 = 6

5! = 1 · 2 · 3 · 4 · 5 = 120

Факториал часто применяется в высшей математике, например в комбинаторике, теории вероятностей и дифференциальном исчислении.
```
py

n = 3
p = 1
list_n = list(range(1, n+1)) # создаеми список от числа n = [0, 1, 2, 3, 4, 5]
#print(list_n)
for num in list_n:
    #print(num)
    p = p * num        # Равносильно P = P * num
print('p =', p)

n = int(input("Введите число: "))
p = 0
list_n = list(range(1, n+1)) # создаеми список от числа n = [0, 1, 2, 3, 4, 5]
#print(list_n)
for num in list_n:
    #print(num)
    p += 1        # Равносильно P = P + 1
    print("*" * p) # печатаем звездочки вместо числа P

weight_of_products= [10, 42.4, 240.1, 101.5, 98, 0.4, 0.3, 15]
# В нашем распоряжении есть список масс товаров, предназначенных для перевозки (в килограммах).
# Необходимо написать алгоритм, который распределял бы товары по типам машин.
max_weight = 100  #Задаём максимальное значение веса груза
num = 0 # Задаём начальный номер груза
# Создаём цикл по элементам списка со значениями массы товаров
for weight in weight_of_products:    # weight — текущее значение веса
    num += 1 # Увеличиваем значение номера груза на 1
    if weight < max_weight: # Если текущий вес меньше максимального,
        print('Product {}, weight: {} -passenger car'.format(num, weight)) # выводим номер груза, его вес и отправляем его в легковую машину.
    else: # В противном случае выводим номер груза, его вес и отправляем его в грузовую машину.
        print('Product {}, weight: {} -truck'.format(num, weight))

```
СПОСОБ 2. ЦИКЛ ПО ИНДЕКСАМ СПИСКА

Для реализации прохода по элементам списка можно использовать более сложный, но в то же время более универсальный вариант. Как вы помните, для обращения к элементам списка можно использовать операцию индексации (квадратные скобки, в которых указывается индекс элемента, который мы хотим получить).

Идея подхода заключается в следующем: в цикле будем перебирать целые числа от 0 до N (не включая N), где N — это длина списка (в нашем случае N = 8). Это будут индексы списка. Числа из последовательности будем заносить в переменную i (на первой итерации i = 0, на второй — i = 1, на третьей — i = 2 и т. д).

Далее в самом теле цикла мы будем обращаться к списку по индексу, получать его элементы — массы товаров, сравнивать их с максимальным значением max_weight и выводить на экран информацию о товаре и типе машины для его перевозки.
```
py

# Задаём список значений массы товаров
weight_of_products = [10, 42.4, 240.1, 101.5, 98, 0.4, 0.3, 15]
max_weight = 100 # Задаём максимальное значение веса груза
N = len(weight_of_products) # Вычисляем длину списка равное 8
# Создаём цикл по последовательности чисел от 0 до N (не включая N)
for i in range(N): # i — текущее значение последовательности
    # Обращаемся к элементу по индексу и сравниваем его с максимумом
    if weight_of_products[i] < max_weight:
        # Если текущий вес меньше максимального,
        # выводим номер груза, его массу и отправляем его в легковую машину.
        print('Product {}, weight: {} -passenger car'.format(i+1, weight_of_products[i]))
    else:
        # В противном случае
        # выводим номер груза, его массу и отправляем его в грузовую машину
        print('Product {}, weight: {} -truck'.format(i+1, weight_of_products[i]))



```
Условие задачи.
1)Мы разрабатываем новый функционал приложения для туристического агентства «Ковёр-самолёт». В нашем распоряжении есть список мест places, которые пользователь хотел бы посетить.
2) Также есть словарь location, ключи которого — места, которые пользователь хочет посетить, а значения — названия стран, где находятся эти места.
3) По эпидемиологическим причинам пользователь не может посетить места, которые находятся вне территории России. Наша задача — заменить заграничные места в списке places на значение 'Unavailable'.
```
py

# НЕ ВЕРНЫЙ ВАРИАНТ НЕ ВЕРНЫЙ ВАРИАНТ НЕ ВЕРНЫЙ ВАРИАНТ НЕ ВЕРНЫЙ ВАРИАНТ НЕ ВЕРНЫЙ ВАРИАНТ
# Список мест, которые хотим посетить.
places = [
    'Red Square',
    'Swallow Nest',
    'Niagara Falls',
    'Grand Canyon',
    'Louvre',
    'Hermitage'
]
# Словарь соответствия мест и стран
location = {
    'Red Square': 'Russia',
    'Swallow Nest': 'Russia',
    'Niagara Falls': 'USA',
    'Grand Canyon': 'USA',
    'Louvre': 'France',
    'Hermitage': 'Russia'
}
# Вычисляем длину списка
N = len(places)
# Создаём цикл по списку мест, которые хотим посетить.
# i — текущее значение последовательности
for i in range(N):
    # places[i] — i-й элемент в списке places
    # Получаем страну из словаря location по ключу
    country = location[places[i]]
    # Сравниваем название стран
    if country != 'Russia':
        # Помечаем место как недоступное
        places[i] = 'Unavailable'
# Выводим результирующий список
print(places)


## Будет выведено:
## ['Red Square', 'Swallow Nest', 'Unavailable', 'Unavailable', 'Unavailable', 'Hermitage']

```
Не получилось по тому,что
Для того чтобы обращаться не к копии элемента, а к самому элементу, необходимо обращаться к нему от имени списка. То есть чтобы заменить элемент под индексом 2 ('Niagara Falls'), нам необходимо обратиться к нему от имени списка places[2] и через оператор присваивания (=) задать ему новое значение.
```
py

# Список мест, которые хотим посетить.
places = [
    'Red Square',
    'Swallow Nest',
    'Niagara Falls',
    'Grand Canyon',
    'Louvre',
    'Hermitage'
]
# Словарь соответствия мест и стран
location = {
    'Red Square': 'Russia',
    'Swallow Nest': 'Russia',
    'Niagara Falls': 'USA',
    'Grand Canyon': 'USA',
    'Louvre': 'France',
    'Hermitage': 'Russia'
}
# Вычисляем длину списка
N = len(places)
# Создаём цикл по списку мест, которые хотим посетить.
# i — текущее значение последовательности
for i in range(N):
    # places[i] — i-й элемент в списке places
    # Получаем страну из словаря location по ключу
    country = location[places[i]]
    # Сравниваем название стран
    if country != 'Russia':
        # Помечаем место как недоступное
        places[i] = 'Unavailable'
# Выводим результирующий список
print(places)


## Будет выведено:
## ['Red Square', 'Swallow Nest', 'Unavailable', 'Unavailable', 'Unavailable', 'Hermitage']

```
Мы рассмотрели очень показательный пример, из которого нам надо сделать важные выводы по работе цикла for со списками:

Если внутри тела цикла for не предполагается изменение списка, по которому проходят итерации, предпочтительнее использовать цикл по элементам списка, т. е. итерируемый объект — сам список. Примеры: вывод содержимого списка на экран, сложение элементов списка, подсчёт элементов по условию (подсчитать, сколько в списке чисел, а сколько строк), передача элементов списка в сторонние функции (отправка сообщений по почте).
Если вы заранее знаете, что внутри тела функции будете изменять список, то цикл ведётся по индексам списка. Цикл по индексам может вестись в случаях, когда в вычислениях участвует не один элемент списка, а сразу несколько. Рассмотрим такой пример чуть позже.
А теперь давайте отработаем навыки владения циклом for.
```
py

my_list = []
for number in range(0, 10):
    my_list.append(number**2) # Квадраты натуральных чисел от 0 до 9
    print(my_list)

my_list = [1]
for i in range(10): # В результирующем списке my_list 11 элементов
    my_list.append(my_list[i] * 2) #  В результате работы цикла список my_list заполняется элементами, причём каждый элемент в два раза больше предыдущего
    print(my_list)

num_list = [1, 10, 3, -5]
num_list.sort() # Отсортировали с помощью метода sort() для списков [-5, 1, 3, 10]
elem = len(num_list)# Вычисляем длину списка равное 4
for i in range(elem): # последовательно выведите на экран элементы этого списка с помощью цикла for
    print("element {}: {}".format(i, num_list[i])) # начинается нумерация с 0, если надо с 1 : format(i+1, num_list[i]

num_list = list(range(0, 100, 3)) # Дан список num_list, состоящий из целых чисел (int).
count_even = 0 # Создаём переменную, в которой будем считать количество чётных элементов.
for i in num_list: # Создаём цикл по элементам списка
    if i%2==0: # Число является чётным, если оно делится на 2 без остатка.
              # Сравниваем остаток от деления на 2 с 0
        count_even +=1 # если условие выполняется прибавляется 1 (будут цыфры от 1 до 17)
        print(count_even)
print("total = ", count_even) # итого 17 элементов

# нужно посчитать сколько строк в списке
mixture_list = [True, 1, -10, 'hello', False, 'string_1', 123, 2.5, [1, 2], 'another']
count_str = 0 # Создаём переменную, в которой будем считать количество элементов типа str.
# С помощью цикла for посчитаем количество элементов типа str в списке.
for i in mixture_list: # создаем цикл
    if i.__class__==str: # проверяем сколько в списке строк
        count_str +=1 # если условие выполняется прибавляется 1
print(count_str)

word_list = ["My", "name", "is", "Sergei", "EOS", "I'm", "from", "Moscow", "EOS"]
text =" ".join(word_list)
print(text)
#for i in word_list:
# Напишите программу для объединения строк из списка word_list в предложения.
# Для решения задачи воспользуйтесь циклом for.
# Результирующий текст запишите в переменную text.
# В решении задачи вам помочь метод strip(),
# который удаляет лишние пробелы с левой и правой стороны от строки.
#string = "     I'm from Moscow.   "
#string = string.strip()
## string = "I'm from Moscow."

word_list = ["My", "name", "is", "Sergei", "EOS", "I'm", "from", "Moscow", "EOS"]
text = ''       #Создаём пустую строку
for i in word_list:
    if i != 'EOS':# Проверяем, что слово - не является обозначением конца предложения
        # Если условие выполняется, добавляем к текущему предложению слово и пробел
        text += i + ' '
    else:
        # В противном случае (слово - обозначение конца предложения),
        # отрезаем последний пробел слева, добавляем точку и пробел справа
        text = text[:-1] + '.' + ' '
text = text.strip() # После объединения текста удаляем лишние пробелы слева и справа
print(f"{text}")
```
```
py
# **АЛГОРИТМ СОЗДАНИЯ ЦИКЛА WHILE:*
```py

x = 21
y = 55
# Задаём начальное значение количества итераций
count = 0
# Записываем условное выражение в цикл
while x < y:
    # Увеличиваем значение переменной x на 2
    # Равносильно x = x + 2
    x += 2
    # Увеличиваем количество итераций на 1
    # Равносильно count = count + 1
    count += 1
# Выводим результирующее количество итераций
print('Number of iterations', count)

## Будет выведено:
## Number of iterations 17

```
Условие задачи. Пассажирский лифт имеет ограничение на перевозку — не более 400 кг единовременно. Пусть входящие в лифт люди имеют одинаковый вес (weight).

Необходимо написать программу, которая должна следить за изменением нагрузки на лифт, сравнивать её с грузоподъёмностью и в случае перевеса выдавать предупреждение 'Overweight N kg'). Например, при перевесе в 15 кг должно быть выведено сообщение 'Overweight 15 kg').
```
py

# Задаём вес входящего в лифт человека
weight = 67
# Задаём грузоподъёмность
max_weight = 400
# Задаём суммарный вес людей в лифте
S = 0
# Создаём цикл, который будет работать, пока S не превысит max_weight.
while S < max_weight: # делай, пока…
    # Увеличиваем суммарный вес
    # Равносильно S = S + weight
    S += weight
    # Выводим значение суммарного веса после обновления
    print('Current sum weight', S)


# Отделяем промежуточный вывод от результата пустой строкой
print()
# Выводим итоговое значение перевеса
print('Overweight {} kg'.format(S - max_weight))

volume = 10 #cосуд вмещает в себя ровно volume литров жидкости.
a_volume = 0 # Задаём суммарный обьем в сосуде
s = 0.0033 * 1000 #по условию в сосуд каждый раз заливается 0.0033 кубаметра воды (перевели в литры)
while a_volume < volume: # делай, пока…
    a_volume += s
    #print('Общий обьем', a_volume) # Выводим значение суммарного обьема после обновления
    cost = a_volume - volume
print() # Отделяем промежуточный вывод от результата пустой строкой
print(cost)# Выводим итоговое значение перелива

```
Условие задачи. Написать цикл, который будет складывать натуральные числа, пока их сумма не превысит 500.

Натуральные числа — это числа 1, 2, 3, 4 и т. д.
```
py

# Создаём накопительную переменную, в которой будем считать сумму.
S = 0
# Задаём текущее натуральное число
n = 1

# Создаём цикл, который будет работать, пока сумма не превысит 500.
while S < 500:  # делай, пока …
    # Увеличиваем сумму, равносильно S = S + n
    S += n
    # Увеличиваем значение натурального числа
    n += 1
    # Выводим строку ожидания
    print("Still counting...")
# Отделяем промежуточный вывод от результата пустой строкой
print()
# Выводим результирующую сумму
print("Sum is: ", S)
# Выводим результирующее количество чисел
print("Numbers total: ", n-1)

value = 159
# Создаём накопительную переменную, в которой будем считать сумму.
number = 1
while number**2 < value: # нужно найти минимальное число number квадрат которого будет больше value
    # Увеличиваем значение натурального числа
    number += 1  #
print(number)

```
Как уже обсуждалось, бывают моменты, когда необходимо специально запустить бесконечный цикл, но вот вопрос — как его потом остановить, не отключая весь скрипт?

Для этого есть ключевое слово break, которое означает, что цикл нужно принудительно прервать.
```
py

# Пусть у нас есть система контроля количества посетителей в магазине,
# максимальное количество покупателей — 10.
n = 1
# В этой программе условие всегда True, цикл будет бесконечным.
while True:
    print("New client !")
    n += 1
    # Условие, при достижении которого цикл while будет принудительно завершён.
    if n > 10:
        break

```
Условие задачи. Представьте себя администратором тайного интернет-сообщества «Три Слепые Мыши» с ограниченным членством. У каждого участника сообщества есть свой позывной и пароль. Позывные и пароли представлены в словаре secret_passwords. Ключи данного словаря — позывные, а значения — пароли.

Необходимо создать бесконечный цикл, который будет проверять, что пользователь, посетивший интернет-сообщество, является его членом. Пользователь вводит свои позывной и пароль с клавиатуры.
```
py

# База позывных и паролей
secret_passwords = {
    'Enot': 'ulybaka',
    'Agent12': '1password1',
    'MouseLulu': 'myshkanaruhka'
}
# Создаём бесконечный цикл
while True:
    # Запрашиваем у пользователя позывной
    name = input('Enter your name: ')
    # Проверяем, что позывной есть среди ключей словаря.
    if name in secret_passwords:
        # Если позывной верный, запрашиваем у пользователя пароль.
        password = input('Enter your password: ')
        # Проверяем, что введённый пароль совпадает со значением по ключу позывного.
        if password == secret_passwords[name]:
            # Если пароль верный, выводим приветственное сообщение.
            print('Welcome')
            # Завершаем цикл
            break
        else:
            # Если пароль неверный, выводим сообщение об ошибке.
            print('Wrong password')
    else:
        # Если позывной неверный, выводим сообщение об ошибке.
        print('Wrong name')

value = 159
# Создаём накопительную переменную, в которой будем считать сумму.
number = 1
while True: # В этой программе условие всегда True, цикл будет бесконечным.
  # нужно найти минимальное число number квадрат которого будет больше value
    number += 1  # Увеличиваем значение натурального числа
    if number**2 > value:  # Условие, при достижении которого цикл while будет принудительно завершён.
        break
print(number)

n=5
i = 0
while i < n:
    i+=1
    print('Hello')
    if i == n:  # Условие, при достижении которого цикл while будет принудительно завершён.
        break

n=156
x = 1
while True: # В этой программе условие всегда True, цикл будет бесконечным.
    x += 1  # Увеличиваем значение натурального числа
    if x ** 2 % n == 0:  # Условие, при достижении которого цикл while будет принудительно завершён.
        break
print(x)

value = 1000
result=1 # Задаём текущее натуральное число
p=1 # Создаём накопительную переменную, в которой будем считать сумму (по условию задачи).
while p <= value: # Цикл должен выполняться до тех пор, пока значение произведения не превысит число value.
    result+=1
    p*=result
print(p)

```
Олег положил money рублей в банк под 8 % годовых с ежегодной капитализацией процентов. Через сколько лет у него на счету будет не менее target_money рублей?

Запишите ответ в переменную year_count.

Для моделирования процесса увеличения денежной суммы на счёте воспользуйтесь циклом while. В случае, когда значение target_money < money, в переменной year_count должен содержаться 0.
```
py

money = 8000 # Олег положил money рублей в банк
target_money = 15000 # Через сколько лет у него на счету будет не менее target_money рублей
year_count = 0 # переменная для счета количества лет
while money <= target_money: # Цикл должен выполняться до тех пор, пока значение произведения не превысит число target_money
    year_count+=1 # # Увеличиваем значение количества лет с каждым циклом
    money= money + (money*8) / 100 # расчет процентов - Олег положил money рублей в банк под 8 % годовых с ежегодной капитализацией процентов
print(year_count)

```
Вы играете в компьютерную игру, дошли до схватки с финальным боссом, но вот незадача: ваш компьютер «заглючил», и вы не можете управлять вашим персонажем. Босс атакует и каждую секунду наносит один удар, который отнимает у персонажа damage единиц здоровья. На схватку с боссом ваш персонаж вышел с health единиц здоровья.

Создайте цикл, позволяющий понять, через сколько секунд босс убьёт вашего персонажа. В результате работы вашей программы в переменной seconds_num должно быть сохранено количество секунд, в течение которых будет длиться схватка.


```
py

health = 500 # персонаж вышел с health единиц здоровья
damage = 80 # удар, который отнимает у персонажа ... единиц здоровья.
seconds_num = 0
while health >= 0: # В этой программе условие при котором health должна быть или равна 0
    seconds_num += 1  # Увеличиваем значение числа (в секундах)
    health = health - damage
print(seconds_num)

```
С помощью цикла while Напишите программу, которая выводит первые n чисел Фибоначчи. Значение n может быть любым
```
py
# Программа для вывода n первых чисел Фибоначчи
n = int(input("Введите число Фибоначчи n: ")) # Считываем n
a = b = 1 # Первое число и Второе число
fibonacci_list = [a] # создаем список куда будут записываться числа Фибоначчи
i = 2 # Счетчик (первые два нам известны (элемент 0 и 1) поэтому ставим 2)
while i <= n: # Создаём цикл,
    a, b = b, a+b # Обновляем значения переменных # Следующее число - сумма двух предыдущих
    i += 1 # Увеличиваем счетчик
    fibonacci_list.append(a) # Добавляем новый элемент последовательности в список
print(fibonacci_list)

temperature = [
    [13, 15, 10],
    [14, 13, 9],
    [8, 9, 6]
]
print(temperature[2][0])

matrix = [
    [1, 2],
    [3, 4],
    [5, 6]
]
# Создаём цикл по элементам списка matrix
# row — текущее значение из списка matrix
for row in matrix:
    # Выводим содержимое на экран
    print('Current row', row)
    # Создаём цикл по элементам списка row
    # elem — текущее значение из списка row
    for elem in row:
        print('Current elem', elem)
    # Отделяем вывод на экран пустой строкой
    print()
## Будет выведено:
## Current row [1, 2]
## Current elem 1
## Current elem 2

## Current row [3, 4]
## Current elem 3
## Current elem 4

## Current row [5, 6]
## Current elem 5
## Current elem 6

matrix = [
    [1, 2],
    [3, 4],
    [5, 6]
]
# Вычисляем длину внешнего списка
N = len(matrix)
# Вычисляем длину вложенного списка
M = len(matrix[0])
# Создаём цикл по последовательности чисел от 0 до N (не включая N)
# i — текущий элемент последовательности (индекс строки)
for i in range(N):
    # Выводим текущее значение i
    print('Current i', i)
    # Выводим i-е значение внешнего списка
    print('Current row', matrix[i])
    # Создаём цикл по последовательности чисел от 0 до M (не включая M)
    # j — текущий элемент последовательности (индекс столбца)
    for j in range(M):
        # Выводим текущее значение j
        print('Current j', j)
        # Выводим элемент под индексами i и j
        print('Current elem', matrix[i][j])
    # Отделяем вывод на экран пустой строкой
    print()


## Будет выведено:
## Current i 0
## Current row [1, 2]
## Current j 0
## Current elem 1
## Current j 1
## Current elem 2

## Current i 1
## Current row [3, 4]
## Current j 0
## Current elem 3
## Current j 1
## Current elem 4

## Current i 2
## Current row [5, 6]
## Current j 0
## Current elem 5
## Current j 1
## Current elem 6

```
Условие задачи. Пользователь даёт нашей умной колонке «Алевтина» задание: поставить будильники особым образом. Будильники должны звонить каждые пять часов, начиная с 10 часов утра. Причём будильник должен прозвенеть дважды в час с перерывом в полчаса. Например, в 15:00 и 15:30.

Необходимо вывести на экран время в которое прозвенят будильники.
```
py

# Создаём список часов
hours = list(range(10, 24, 5))
# Создаём список минут
minutes = list(range(0, 60, 30))
# Создаём цикл по элементам списка часов
for hour in hours: #hour — текущее значение часа (10, 15, 20)
    # Создаём цикл по элементам списка минут
    for minute in minutes: #minute — текущее значение минуты
        # Выводим время
        #print('Alarm is set {}:{}'.format(hour, minute))
# Alarm is set 10:0
# Alarm is set 10:30
# Alarm is set 15:0
# Alarm is set 15:30
# Alarm is set 20:0
# Alarm is set 20:30
#Мы видим, что для нулевой минуты результаты выводятся в непривычном и формате,
# например, 10:0, а не 10:00. Давайте исправим это
        if minute == 0:
            # Добавляем еще один 0 к минутам
            print('Alarm is set {}:{}0'.format(hour, minute))
        else:
            print('Alarm is set {}:{}'.format(hour, minute))

```
4.2 задание на самопроверку
```
py

# Создаём список часов
hours = list(range(9, 24, 1))
# Создаём список минут
minutes = list(range(0, 60, 15))
for hour in hours: #hour — текущее значение часа (9,10,11,12.....24)
    # Создаём цикл по элементам списка минут
    for minute in minutes: #minute — текущее значение минуты(15,30,15,60)
        # Выводим время
        #print('Alarm is set {}:{}'.format(hour, minute))
        if minute == 0:
            # Добавляем еще один 0 к минутам
            print('Alarm is set {}:{}0'.format(hour, minute))
        else:
            print('Alarm is set {}:{}'.format(hour, minute))

```
Условие задачи. Дан список строк str_list = ['text', 'morning', 'notepad', 'television', 'ornament']. Необходимо подсчитать, сколько всего раз во всех строках списка встречается буква 'e'
```py

# Заданный список строк
str_list = ['text', 'morning', 'notepad', 'television', 'ornament']
# Задаём начальное количество символов 'e'
count = 0
# Создаём цикл по элементам списка str_list
for text in str_list:
    # Создаём цикл по символам в строке text
    for symbol in text:
        # Проверяем условие, что текущий символ == 'e'
        if symbol == 'e':
            # Если условие истинно, увеличиваем количество символов 'e'.
            count += 1
# Выводим результат
print("Count symbol 'e':", count)


## Будет выведено:
## Count symbol 'e': 5

# ИЛИ МОЖНО БЫЛО ЗАПИСАТЬ
# Заданный список строк
str_list = ['text', 'morning', 'notepad', 'television', 'ornament']
# Задаём начальное количество символов 'e'
count = 0
# Создаём цикл по элементам списка str_list
for text in str_list:
    # Увеличиваем количество символов 'e'
    # Метод str.count() считает, сколько раз символ встречается в строке text.
    count += text.count('e')
# Выводим результат
print("Count symbol 'e':", count)


## Будет выведено:
## Count symbol 'e': 5

```
4.3 на самопроверк
```py

text_list = [
    'afbaad',
    'faaf',
    'afaga',
    'agag'
]
# Задаём начальное количество символов 'а'
count = 0
# Создаём цикл по элементам списка str_list
for text in text_list:
    # Увеличиваем количество символов 'а'
    # Метод str.count() считает, сколько раз символ встречается в строке text.
    count += text.count('a')
# Выводим результат
print("Count symbol 'a':", count)

```
Дана двумерная матрица 3x3 (список списков). Необходимо определить минимумы в каждой её строке
```py

# В цикле реализуем стандартный алгоритм поиска минимального элемента в списке row.
row = [9, 2, 1]
# Начальное значение кандидата на минимум
min_value = row[0]
# Создаём цикл по элементам списка row
for elem in row: # elem — текущий элемент из списка row
    # Проверяем условие, что текущий элемент меньше кандидата на минимум.
    if elem < min_value:
        # Если условие выполняется, заменяем кандидата на минимум.
        min_value = elem
# Выводим результат
print('Min value in row:', min_value)


## Будет выведено:
## Min value in row: 1

# Заданная матрица
random_matrix = [
    [9, 2, 1],
    [2, 5, 3],
    [4, 8, 5]
]
# Задаём пустой список с минимальными значениями строк
min_value_rows = []
# Создаём цикл по строкам матрицы random_matrix
for row in random_matrix: # row — текущая строка таблицы
    # Задаём начальное значение кандидата на минимум
    min_value = row[0]
    # Создаём цикл по элементам списка row
    # elem — текущий элемент из списка row
    for elem in row:
        # Проверяем условие, что текущий элемент меньше кандидата на минимум.
        if elem < min_value:
            # Если условие выполняется, заменяем кандидата на минимум.
            min_value = elem
    # Добавляем полученный минимум строки в список
    min_value_rows.append(min_value)
# Выводим минимальные элементы
print("Minimal elements:", min_value_rows)


## Будет выведено:
## Minimal elements: [1, 2, 4]

```
Дана двумерная матрица random_matrix размера n x n (список списков). Напишите программу, которая определяет максимумы в каждой строке исходной матрицы.

Максимумы должны быть представлены в виде списка. Запишите результат в переменную max_value_rows.

Задача 4.4
```py

random_matrix = [
    [9, 121, 1, 10, 42],
    [91, 5, 3, 34, -1],
    [-8, 98, 5, 24, -420]
]
# Задаём пустой список с масимальными значениями строк
max_value_rows = []
# Создаём цикл по строкам матрицы random_matrix
for row in random_matrix: # row — текущая строка таблицы
    # Задаём начальное значение кандидата на максимум
    max_value = row[0]
    # Создаём цикл по элементам списка row
    # elem — текущий элемент из списка row
    for elem in row:
        # Проверяем условие, что текущий элемент больше кандидата на максиум.
        if elem > max_value:
            # Если условие выполняется, заменяем кандидата на максимум.
            max_value = elem
    # Добавляем полученный максимум строки в список
    max_value_rows.append(max_value)
# Выводим максимальные элементы
print("max_value_rows =", max_value_rows)

```
Условие задачи. Нам предоставлены данные о баллах пяти студентов по трём экзаменам. Данные находятся во вложенном списке student_scores.
Необходимо найти средний балл студентов по каждому из экзаменов и общий средний балл по всем экзаменам.

Очевидно, что средний балл по каждому из экзаменов рассчитывается как:
общий бал по экзаемну \ количество студентов

Общий средний балл рассчитывается так:
общий бал по всем экзаменам \ количество студентов * количество экзаменов
```py

student_scores = [
    [56, 90, 80],
    [80, 86, 92],
    [91, 76, 89],
    [91, 42, 60],
    [65, 30, 90]
]
N = len(student_scores) # Задаём число студентов
M = len(student_scores[0]) # Задаём число экзаменов
summa = 0 # Задаём начальное значение общего балла
math_sum = 0 # Задаём начальное значение общего балла по математике
info_sum = 0 # Задаём начальное значение общего балла по информатике
rus_sum = 0 # Задаём начальное значение общего балла по русскому языку
# Создаём цикл по последовательности от 0 до N (не включая N)
for i in range(N): # i — индекс строки
    # Добавляем баллы по математике i-го студента
    math_sum += student_scores[i][0]
    # Добавляем баллы по информатике i-го студента
    info_sum += student_scores[i][1]
    # Добавляем баллы по русскому языку i-го студента
    rus_sum += student_scores[i][2]
    # Создаём цикл по последовательности от 0 до M (не включая M)
    for j in range(M): # j — индекс столбца
        # Добавляем баллы i-го студента по j-му экзамену
        summa += student_scores[i][j]
# Выводим средний балл по математике
print('Average math score', math_sum / N)
# Выводим средний балл по информатике
print('Average info score', info_sum / N)
# Выводим средний балл по русскому языку
print('Average rus score', rus_sum / N)
# Выводим общий средний балл
print('Average score', summa /(N*M))


## Будет выведено:
## Average math score 76.6
## Average info score 64.8
## Average rus score 82.2
## Average score 74.53333333333333

test_matrix = [
    [1, 2, 3],
    [7, -1, 2],
    [123, 2, -1],
    [123, 5, 1]
]
# Вычисляем длину внешнего списка
N = len(test_matrix)
# Вычисляем длину вложенного списка
M = len(test_matrix[0])
Si = 0 # Задаём переменную суммы
Sj = 0
# Создаём цикл по последовательности чисел от 0 до N (не включая N)
# i — текущий элемент последовательности (индекс строки)
for i in range(N):
    Si += i
    for j in range(M):
        Sj += j
if Si == Sj:

test_matrix = [
    [1, 2, 3],
    [7, -1, 2],
    [123, 2, -1],
    [123, 5, 1]
]
# Вычисляем число строк в матрице
num_lines = len(test_matrix)
# Задаём начальное количество строк, длина которых совпадает с числом строк в матрице.
count = 0
# Создаём цикл по строкам матрицы
for line in test_matrix: #line — текущая строка матрицы
    # Проверяем, что длина текущей строки равна количеству строк.
    if len(line) == num_lines:
        # Если условие выполняется, увеличиваем количество строк,
        # длина которых совпадает с числом строк в матрице.
        count += 1
# Cравниваем полученное число с числом строк в матрице
is_square = num_lines == count

```
При формировании данных о температуре за три летних месяца допустили ошибку: некоторые значения оказались отрицательными. Вам необходимо заменить все отрицательные значения на положительные.

Для того, чтобы сделать из отрицательного числа положительное в Python, можно воспользоваться встроенной функцией abs (). Данная функция возвращает модуль числа, то есть абсолютное значение.
```py

temp = [
    [25, 27, 28, 26, 27, -26, -25, -2, 26],
    [21, 22, 28, 27, 28, 26, 25, 19, 26],
    [-19, 21, 25, -27, 28, 25, 21, 20, 26]
]
p=[]
for i in temp:
    p.append([abs(x) for x in i[0:]])
temp.clear()
temp.append(p)
print(temp)

```
сделали учителя!!!!!!!!!!
```py

# Создаём цикл по диапазону от 0 до N-1, где N — длина внешнего списка.
for i in range(len(temp)):
    row = temp[i]
    # Создаём цикл по диапазону от 0 до M-1, где M — длина внутреннего списка.
    for j in range(len(row)):
        # Проверяем, что элемент, стоящий в i-ой строке и j-ом столбце, отрицательный.
        if temp[i][j] < 0:
            # Если условие выполняется, умножаем элемент на -1, чтобы сменить знак.
            temp[i][j] *= -1

```
Напишите программу, которая вычисляет средние значения удовлетворённости клиентов за каждый месяц (среднее значение в каждом из вложенных списков), округлённые до двух знаков после точки-разделителя, а также максимальное из этих средних значений
```py

customer_satisfaction = [
    [0.87, 0.56, 0.77],
    [0.22, 0.46, 0.56, 0.89, 0.95],
    [0.45, 0.44, 0.68],
    [0.73, 0.88, 0.95, 0.49]
]
# Инициализируем пустой список month_satisfaction
month_satisfaction = []
# Создаём цикл по внешнему списку
for row in customer_satisfaction:
    # Инициализируем сумму и количество
    summa = 0
    count = 0
    # Создаём цикл по внутреннему списку
    for value in row:
        # Обновляем сумму и количество
        summa += value
        count += 1
    # Вычисляем среднее
    mean_s = round(summa / count, 2)
    # Добавляем результат в новый список
    month_satisfaction.append(mean_s)

# Инициализируем значение максимальной удовлетворённости
max_satisfaction = 0
# Создаём цикл по элементам списка со значениями удовлетворённости по месяцам
for s in month_satisfaction:
    # Проверяем, что текущее значение удовлетворённости выше
    if s > max_satisfaction:
        # Обновляем максимальную удовлетворенность
        max_satisfaction = s
        print(s)

```
**5 вложенные циклы**

Условие задачи. У нас есть список ежедневной динамики числа пользователей приложения.

Если элемент списка положительный, то число новых пользователей больше числа ушедших пользователей (прирост).
Если элемент списка отрицательный, то число ушедших пользователей больше числа новых (отток).
user_dynamics = [-5, 2, 4, 8, 12, -7, 5]
Мы бы хотели вывести этот список на экран поэлементно в виде {номер дня}: {динамика}. Например, для первого дня вывод должен быть "Day 1: -5".

**Способ 1. Цикл по элементам списка**
```py

# Заданный список динамики числа пользователей
user_dynamics = [-5, 2, 4, 8, 12, -7, 5]
# Задаём номер дня
number = 1
# Создаём цикл по элементам списка user_dynamics
for dynamic in user_dynamics: # dynamic — текущее значение из списка
    # Выводим номер дня и динамику на этот день
    print("Day {} : {}".format(number, dynamic))
    # Увеличиваем номер дня
    number += 1

```
**Способ 2. Цикл по индексам списка*
```py

# Заданный список динамики числа пользователей
user_dynamics = [-5, 2, 4, 8, 12, -7, 5]
# Вычисляем длину списка
N = len(user_dynamics)
# Создаём цикл по элементам последовательности от 0 до N (не включая N)
for i in range(N): # i — текущий индекс
    # Выводим номер дня и динамику на этот день
    print("Day {} : {}".format(i+1, user_dynamics[i]))

```
Отлично, мы повторили изученный ранее материал. Но оказывается, что можно объединить два указанных способа и создать цикл по индексам и элементам последовательности одновременно.** Для этой цели служит функция enumerate(). **Она используется в цикле for и на каждой его итерации выдаёт индекс элемента последовательности (списка), а также его значение
```py

my_list = [5, 9, 13]
# Создаём цикл одновременно по индексам и элементам списка
for index, value in enumerate(my_list):
    # Выводим индекс и значение
    print(index, value)
## Будет выведено:
## 0 5
## 1 9
## 2 13

```
**Способ 3. Цикл по индексам и элементам одновременно**

Чем последнее решение лучше предыдущих?

В отличие от первого решения (перебора элементов списка), нам не нужно создавать дополнительную переменную, отвечающую за номер дня, и увеличивать её в цикле. Номер дня можно посчитать как текущий индекс + 1.
В отличие от второго решения (перебора индексов списка), нам не нужно заранее вычислять длину списка, а также обращаться к списку по индексу.
Полученное решение сокращает количество кода и вносит в него большую ясность.
```py

# Заданный список динамики числа пользователей
user_dynamics = [-5, 2, 4, 8, 12, -7, 5]
# Создаём цикл по индексам и элементам списка
# i — индекс текущего элемента, dynamic — текущее значение из списка
for i, dynamic in enumerate(user_dynamics):
    # Выводим номер дня и динамику на этот день
    print("Day {} : {}".format(i+1, dynamic))


## Будет выведено:
## Day 1 : -5
## Day 2 : 2    и т.д.

```
5.3 задание на самопроверку
Ваша задача — переписать код так, чтобы он работал с помощью функции enumerate(). Таким образом, вам необходимо создать цикл по индексам и элементам списка user_dynamics.
```py

user_dynamics = [-5, 2, 4, 8, 12, -7, 5]
number_negative = None #объявляем переменную, в которой будем хранить номер последнего дня оттока, изначально она пустая (None)
# Создаём цикл по индексам и элементам списка
# i — индекс текущего элемента, dynamic — текущее значение из списка
for i, dynamic in enumerate(user_dynamics):
    if dynamic < 0: #если условие истинно,
        number_negative = i+1  #перезаписываем значение номера дня
        print("Churn value: ", user_dynamics[i]) # выводим количество ушедших в этот день пользователей
        print("Number day: ", number_negative) # выводим номер дня

str_list = ['Hello', 'my', 'name', 'is', 'Ezeikel', 'I', 'like', 'knitting']
cut_str_list = []
# Создаём цикл по индексам и элементам списка
# number — номер текущей строки, str — строка
for number, str in enumerate(str_list):
# Добавляем результат в новый список
    cut_str_list.append([number, str[:3]])  # вставляем в список: номер строки и строку со срезом первых 3 символов
print(cut_str_list) #

```
Оператор **break**. Он может использоваться как в цикле while, так и в цикле for

Необходимо написать программу, которая переносит вещи из списка **to_inventory** в список **inventory**, но если количество этих вещей превысит 3, то выводится предупреждение и перенос вещей заканчивается.
```py

# Список вещей, которые нужно положить в инвентарь.
to_inventory = ['Blood Moon Sword', 'Sunset-colored sword', 'Bow of Stars', 'Gain Stone']
# Задаём пустой инвентарь
inventory = []
# Создаём цикл по элементам списка to_inventory
# item — текущий элемент списка
for item in to_inventory:
    # Проверяем условие, что инвентарь уже заполнен.
    if len(inventory) == 3:
        # Если условие выполняется,выводим предупреждение об ошибке.
        print('Inventory is full!')
        # Завершаем работу цикла
        break
    # Если цикл не завершился добавляем предмет в инвентарь
    inventory.append(item)
# Выводим результирующий инвентарь
print(inventory)


# Будет выведено:
# Inventory is full!
# ['Blood Moon Sword', 'Sunset-colored sword', 'Bow of Stars']

```
В теории шифрования очень активно используются степени числа. Берётся число и несколько раз возводится в некоторую степень. Для дешифрации нужно определить, какое число было задано изначально.

Например, изначально задано простое число 3, его возвели в степень 4 и получили число 81.

Необходимо написать программу, которая проверяет, что число n является степенью числа 3.

Напомним, за операцию взятия остатка от деления в Python отвечает оператор %, а за целочисленное деление — //.

Например, рассмотрим число 27:

Остаток от деления на 3: 27 % 3 = 0. Результат целочисленного деления 27 // 3 = 9.
Остаток от деления на 3: 9 % 3 = 0. Результат целочисленного деления 9 // 3 = 3.
Остаток от деления на 3: 3 % 3 = 0. Результат целочисленного деления 3 // 3 = 1.
Получили 1, а значит 27 является степенью числа 3. Выходим из цикла.

А теперь рассмотрим число 12:

Остаток от деления на 3: 12 % 3 = 0. Результат целочисленного деления 12 // 3 = 4.
Остаток от деления на 3: 4 % 3 = 1.
Остаток не равен 0, а это значит число 12 не является степенью числа 3. Выходим из цикла.

Итак, организуем процедуру проверки в коде:
```py

# Задаём число
n = 27
# Создаём бесконечный цикл
while True:
    # Проверяем условие, что остаток от деления на 3 равен 0.
    if n % 3 == 0:
        # Если условие выполняется, новое число — результат целочисленного деления на 3.
        n = n // 3
        # Проверяем условие, что в результате деления получили 1.
        if n == 1:
            # Выводим утвердительное сообщение
            print('n - is the power of the number 3!')
            # Выходим из цикла
            break
    else:
        # В противном случае выводим сообщение-опровержение
        print('n - is not the power of the number 3!')
        # Выходим из цикла
        break
## Будет выведено:
## n - is the power of the number 3!

```
Задача 5.7

Допишите программу, которая проверяет гипотезу Сиракуз.

Гипотеза Сиракуз заключается в том, что любое натуральное число n можно свести к 1, если повторять над ним следующие действия:

если число чётное, разделить его нацело пополам, т. е. n = n // 2;
если нечётное — умножить на 3, прибавить 1 и результат нацело разделить на 2, т. е. n = (n * 3 + 1) // 2.
Мы тестируем только целые числа!
```py

n  = 25921
origin = n
# Создаём бесконечный цикл
while True:
     # Проверяем условие, что число чётное.
    if n % 2 == 0:
        # Если число чётное, делим его на 2.
        n = n // 2
    else:
        # если нечётное — умножаем на 3, прибавляем 1 и результат нацело разделить на 2
        n = (n * 3 + 1) // 2
    if n == 1:
        # Если условие выполняется, выводим утвердительное сообщение.
        print(f'Syracuse hypothesis holds for number {origin}')
        # Выходим из цикла
        break

```
Сделал я (чуть длиннее
```py

n  = 25921
origin = n
# Создаём бесконечный цикл
while True:
    if n % 2 == 0:
        # Если условие выполняется, новое число — результат целочисленного деления на 3.
        n = n // 2
        # Проверяем условие, что в результате деления получили 1.
        if n == 1:
            # Выводим утвердительное сообщение
            print(f'Syracuse hypothesis holds for number {origin}')
            # Выходим из цикла
            break
    else:
        n = (n * 3 + 1) // 2 # если нечётное — умножить на 3, прибавить 1 и результат нацело разделить на 2
        if n == 1:
        # Если условие выполняется, выводим утвердительное сообщение.
            print(f'Syracuse hypothesis holds for number {origin}')
            # Выходим из цикла
            break

```
Если в теле цикла встречается ключевое слово **continue,** то цикл пропускает весь код до конца тела цикла и переходит на следующий шаг.

Условие задачи. Дан словарь клиентов и статус их программы скидок. Ключами словаря являются идентификаторы клиентов, а значениями — статусы программы скидок ('yes' — активен, 'no' — неактивен).

client_status = {103303: 'yes', 103902: 'no'}

В честь Нового года магазин хочет отправить подарочные сертификаты всем, у кого активен статус программы скидок.

Необходимо написать программу, которая выводит идентификаторы клиентов, которым полагается подарочный сертификат.
```py

client_status = {
    103303: 'yes',
    103044: 'no',
    100423: 'yes',
    103032: 'no',
    103902: 'no'
}
# Создаём цикл по ключам словаря client_status
for user_id in client_status: # user_id — текущий ключ словаря
    if client_status[user_id] == 'no':
        # Если текущий статус == 'no', переходим на следующую итерацию
        continue
    else:
        # В противном случае выводим сообщение об отправке сертификата
        print('Send present user', user_id)


# Будет выведено:
# Send present user 103303
# Send present user 100423

```
Задача
Дан словарь mixture_dict. Значения в нём могут быть трёх типов: строки (str) или числа (int и float).

Посчитайте, сколько значений в словаре mixture_dict являются числами. Результат занесите в переменную count_numbers. Используйте в своём коде оператор continue.
```py

mixture_dict = {'a': 15, 'b': 10.5, 'c': '15', 'd': 50, 'e': 15, 'f': '15'}
count_numbers = 0
## count_numbers = 4
# Создаём цикл по ключам словаря client_status
for mixture in mixture_dict: # my_dict — текущий ключ словаря
    if type(mixture_dict[mixture]) is str:
        # Если условие выполняется, переходите на следующую итерацию.
        continue
    else:
        count_numbers += 1
print('count_numbers = ', count_numbers)

```
Помимо ключевых слов **break** и **continue**, существует ключевое слово **pass**. Заглушка pass означает «ничего не делать». Обычно мы используем её, потому что Python не позволяет создавать класс, функцию, цикл или оператор if без кода внутри.

# **В приведённом ниже примере «вылетит» ошибка, если внутри i > 3 не будет кода, поэтому мы используем pass:**
```py

# Задан список
lst = [1,2,3,4,5]
# Создаём цикл по элементам списка
for i in lst:
    if i > 3:
        # Если i больше 3, ничего не делаем
        pass
    else:
        # В противном случае выводим элемент
        print(i)

```
Условие задачи. Подсчитать количество вхождений каждого символа в заданном тексте. В результате работы программы должен быть сформирован словарь, ключи которого — символы текста, а значения — количество вхождений символа в тексте.

Примечание. Символы переноса строки в компьютере обозначаются специальным символом '\n'.
```py

text =
```py
The rabbit-hole went straight on like a tunnel for some way, and then dipped suddenly down, so suddenly that Alice had not a moment to think about stopping herself before she found herself falling down a very deep well.

Either the well was very deep, or she fell very slowly, for she had plenty of time as she went down to look about her and to wonder what was going to happen next. First, she tried to look down and make out what she was coming to, but it was too dark to see anything; then she looked at the sides of the well, and noticed that they were filled with cupboards and book-shelves; here and there she saw maps and pictures hung upon pegs. She took down a jar from one of the shelves as she passed; it was labelled `ORANGE MARMALADE', but to her great disappointment it was empty: she did not like to drop the jar for fear of killing somebody, so managed to put it into one of the cupboards as she fell past it.

`Well!' thought Alice to herself, `after such a fall as this, I shall think nothing of tumbling down stairs! How brave they'll all think me at home! Why, I wouldn't say anything about it, even if I fell off the top of the house!' (Which was very likely true.)
```
#Условимся, что символы в верхнем и нижнем регистре будем считать одинаковыми, поэтому приведём текст в нижний регистр и удалим все пробелы и символы переноса строки.
#Чтобы привести текст в нижний регистр, используем метод lower().
#Для того чтобы заменить пробелы и символы переноса строки ('\n') Для того чтобы заменить пробелы и символы переноса строки ('\n')
# Приводим текст к нижнему регистру
text = text.lower()
# Заменяем пробелы на пустые строки
text = text.replace(" ", "")
# Заменяем символы переноса строки на пустые строки
text = text.replace("\n", "")
# Создаём пустой словарь для подсчёта количества символов
count_dict = {}
# Создаём цикл по символам в строке text
for symbol in text: # symbol — текущий символ в тексте
    # Проверяем условие, что символа ещё нет среди ключей словаря.
    if symbol not in count_dict:
        # Если условие выполняется, заносим символ в словарь со значением 1.
        count_dict[symbol] = 1 #
    else:
        # В противном случае увеличиваем частоту символа
        count_dict[symbol] += 1
# Выводим результирующий словарь
print(count_dict)
## {'t': 88, 'h': 63, 'e': 112, 'r': 39, 'a': 70, 'b': 15, 'i': 47, '-': 2, 'o': 80, 'l': 55, 'w': 31, 'n': 57, 's': 60, 'g': 17, 'k': 14, 'u': 22, 'f': 28, 'm': 17, 'y': 18, ',': 13, 'd': 43, 'p': 23, 'c': 9, 'v': 8, '.': 5, 'x': 1, ';': 3, 'j': 2, '`': 3, "'": 5, ':': 1, '!': 4, '(': 1, ')': 1}

```
Задача 5.11

Дана переменная text, в которой содержится некоторый текст. В этом тексте могут присутствовать знаки препинания: точки ('.'), запятые(','), точки с запятой (';'), вопросительные ('?') и восклицательные знаки ('!'), а также тире ('—').

Напишите программу, формирующую словарь count_punctuation, ключами которого являются знаки препинания, а значениями — их количество в тексте.

Обратите внимание, что если какого-то из шести указанных знаков препинания нет в тексте, то в итоговом словаре значение, соответствующее этому знаку препинания, должно быть равно 0. Также имейте в виду, что тире и дефис являются разными символами.

```py

text = """
She sells sea shells on the sea shore;
The shells that she sells are sea shells I am sure.
So if she sells sea shells on the sea shore,
I am sure that the shells are sea shore shells.
"""
count_punctuation = {',': 0, '.': 0, '?': 0, '!': 0, ';': 0, '—': 0}
# Создаём цикл по символам в строке text
for symbol in text: # symbol — текущий символ в тексте
    # Проверяем условие, что символа есть среди ключей словаря.
    if symbol in count_punctuation:
        # Если условие выполняется увеличиваем частоту символа
        count_punctuation [symbol] += 1
# Выводим результирующий словарь
print(count_punctuation)

```
Условие задачи. Подсчитать количество вхождений каждого слова в заданном тексте. В результате работы программы должен быть сформирован словарь, ключи которого — слова текста, а значения — количество вхождений слов в тексте
```py

text = """
She sells sea shells on the sea shore;
The shells that she sells are sea shells I am sure.
So if she sells sea shells on the sea shore,
I am sure that the shells are sea shore shells.
"""
# Приводим текст к нижнему регистру
text = text.lower()
# Заменяем символы переноса строки на пробелы
text = text.replace("\n", " ")
# Заменяем запятые на пустые строки
text = text.replace(",", "")
# Заменяем точки на пустые строки
text = text.replace(".", "")
# Заменяем точки с запятыми на пустые строки
text = text.replace(";", "")
# Разделяем текст на слова
word_list = text.split()
# Создаём пустой словарь для подсчёта количества слов
count_dict = {}
# Создаём цикл по словам в списке word_list
# word — текущее слово из списка word_list
for word in word_list:
    # Проверяем условие, что слова ещё нет среди ключей словаря.
    if word not in count_dict:
        # Если условие выполняется, заносим слово в словарь со значением 1.
        count_dict[word] = 1
    else:
        # В противном случае увеличиваем частоту слова
        count_dict[word] += 1
# Выводим результирующий словарь
print(count_dict)
## Будет выведено:
## {'she': 3, 'sells': 3, 'sea': 6, 'shells': 6, 'on': 2, 'the': 4, 'shore': 3, 'that': 2, 'are': 2, 'i': 2, 'am': 2, 'sure': 2, 'so': 1, 'if': 1}

```
Задача 5.12

Дано предложение, хранящееся в переменной sentence.

Выполните следующие действия:

Приведите все символы в предложении к нижнему регистру.
Исключите знаки препинания (запятые и точки).
Разделите строку по пробелам и создайте список слов, которые входят в предложение.
Подсчитайте количество повторений каждого слова.
Для подсчёта слов используйте словарь. Ключами словаря будут слова, а значениями — число вхождений этих слов в предложение. В результате работы вашей программы в переменной word_dict должен храниться результирующий словарь.
```py

sentence = 'A roboT MAY Not injure a humAn BEING or, tHROugh INACtion, allow a human BEING to come to harm.'
## word_dict = {'a': 3, 'robot': 1, 'may': 1, 'not': 1, 'injure': 1, 'human': 2, 'being': 2, 'or': 1, 'through': 1, 'inaction': 1, 'allow': 1, 'to': 2, 'come': 1, 'harm': 1}
# Приводим текст к нижнему регистру
sentence = sentence.lower()
# Заменяем символы переноса строки на пробелы
sentence = sentence.replace("\n", " ")
# Заменяем запятые на пустые строки
sentence = sentence.replace(",", "")
# Заменяем точки на пустые строки
sentence = sentence.replace(".", "")
# Разделяем текст на слова
word_list = sentence.split() # ['she', 'sells', 'sea', 'shells', 'on', 'the'...]
# Создаём пустой словарь для подсчёта количества слов
word_dict = {}
# Создаём цикл по словам в списке word_list
for word in word_list:
    # Проверяем условие, что слова ещё нет среди ключей словаря.
    if word not in word_dict:
        # Если условие выполняется, заносим слово в словарь со значением 1.
        word_dict[word] = 1
    else:
        # В противном случае увеличиваем частоту слова
        word_dict[word] += 1
# Выводим результирующий словарь
print(word_dict)

```
Задача 5.13

Дан список из строк str_list. Напишите программу для подсчёта количества вхождений заданного символа в каждую из строк этого списка. Искомый символ хранится в переменной symbol_to_check.

Для подсчёта используйте словарь: в качестве ключа запишите в него строку, в качестве значения — число вхождений искомого символа в эту строку. Для хранения словаря используйте переменную с именем word_dict.
```py

str_list = ["text", "morning", "notepad", "television", "ornament"]
symbol_to_check = 't'
word_dict = {} # создаем пустой словарь для подсчета символа
## word_dict = {'text': 2, 'morning': 0, 'notepad': 1, 'television': 1, 'ornament': 1}
for word in str_list:
    # Заносим текущее слово в словарь со значением 0
    word_dict[word] = 0
    # Создаём внутренний цикл по символам в строке
    for dict in word:
        # Проверяем условие, что текущий символ в строке — это искомый символ
        if dict == symbol_to_check:
            # Если условие выполняется, увеличиваем количество символов в слове
            word_dict[word] += 1
print(word_dict)

```
# **# Контрольный срез знаний ! В рамках практического кейса мы сначала вместе познакомимся с исходными данными и произведем некоторые манипуляции над ними. После чего вам предстоит самостоятельно выполнить несколько заданий на тему поиска наиболее значимых слов в тексте с помощью методов статистического анализа текста.*
```py

# Импортируем библиотеку для выполнения HTTP-запросов в интернет
import requests

# Читаем текстовый файл по url-ссылке
data = requests.get("https://raw.githubusercontent.com/SkillfactoryDS/Datasets/master/war_peace_processed.txt").text

# Предобрабатываем текстовый файл
data = data.split('\n')
data.remove('')
data = data + ['[new chapter]']

# Выводим первые 100 слов из книги
#print(data[:100])
#получаем ['1', 'в', 'два', 'раза', 'короче', 'и', 'в', 'пять', 'раз', 'интереснее', '2', 'почти', 'нет', 'философических', 'отступлений', '3', 'в', 'сто', 'раз', 'легче', 'читать', 'весь', 'французский', 'текст', 'заменен', 'русским', 'в', 'переводе', 'самого', 'толстого', '4', 'гораздо', 'больше', 'мира', 'и', 'меньше', 'войны', '5', 'хеппи-энд', 'эти', 'слова', 'я', 'поместил', 'семь', 'лет', 'назад', 'на', 'обложку', 'предыдущего', 'издания', 'указав', 'в', 'аннотации', 'первая', 'полная', 'редакция', 'великого', 'романа', 'созданная', 'к', 'концу', '1866', 'года', 'до', 'того', 'как', 'толстой', 'переделал', 'его', 'в', '1867--1869', 'годах', '--', 'и', 'что', 'я', 'использовал', 'такие-то', 'публикации', 'думая', 'что', 'все', 'всё', 'знают', 'я', 'не', 'объяснил', 'откуда', 'взялась', 'эта', 'первая', 'редакция', 'я', 'оказался', 'неправ', 'и', 'в', 'результате', 'оголтелые', 'и']
# Для начала найдем общее количество слов и количество уникальных слов в тексте
# Превращаем список в множество, удаляя дублирующиеся слова
word_set = set(data)
# Удаляем из множества слово, символизирующее раздел между главами
word_set.discard('[new chapter]')
# Выводим результаты
#print('Общее количество слов: {}'.format(len(data)))
#print('Общее количество уникальных слов: {}'.format(len(word_set)))
#Получаем Общее количество слов: 300080
#Общее количество уникальных слов: 38210

# Давайте напишем программу, которая посчитает частоту каждого слова. Для этого создадим словарь, ключами которого будут являться слова, а значения - количество вхождений этого слова в текст произведения. Заодно подсчитаем количество глав

# Инициализируем пустой словарь
word_counts = {}
# Инициализируем количество глав
count_chapter = 0
# Создаем цикл по всем словам из списка слов
for word in data:
    # Проверяем, что текущее слово - обозначение новой главы
    if word == '[new chapter]':
        # Если условие выполняется, то увеличиваем количество глав на 1
        count_chapter += 1
        # Переходим на новую итерацию цикла
        continue
    # Проверяем, что текущего слова еще нет в словаре слов
    if word not in word_counts:
        # Если условие выполняется, инициализируем новый ключ 1
        word_counts[word] = 1
    else:
        # В противном случае, увеличиваем количество слов на 1
        word_counts[word] += 1

# Выводим количество глав
#print('Количество глав: {}'.format(count_chapter))
#Получаем Количество глав: 171
# Создаем цикл по ключам и их порядковым номерам полученного словаря
for i, key in enumerate(word_counts):
    # Выводим только первые 10 слов
    if i == 10:
        break
    #print(key, word_counts[key])
#Получаем
#Количество глав: 171
#1 9
#в 6996
#два 214
#раза 34
#короче 2
#и 14591
#пять 60
#раз 295
#интереснее 3
#2 11

# Разделим все слова на главы. Для этого создадим список, в котором будем хранить списки - слова из определенной главы.

# Инициализируем общий список, в котором будем хранить списки слов в каждой главе
chapter_data = []
# Инициализируем список слов, в котором будет хранить слова одной главы
chapter_words = []

# Создаем цикл по всем словам из списка
for word in data:
    # Проверяем, что текущее слово - обозначение новой главы
    if word == '[new chapter]':
        # Если условие выполняется, добавляем список со словами из главы в общий список
        chapter_data.append(chapter_words)
        # Обновляем (перезаписываем) список со словами из текущей главы
        chapter_words = []
    else:
        # В противном случае, добавляем текущее слово в список со словами из главы
        chapter_words.append(word)

# Проверяем, что у нас получилось столько же списков, сколько глав в произведении
#print('Вложенный список содержит {} внутренних списка'.format(len(chapter_data)))
# Выведем первые 100 слов 0-ой главы
# print(chapter_data[0][:100])
# Получаем
# Вложенный список содержит 171 внутренних списка
#['1', 'в', 'два', 'раза', 'короче', 'и', 'в', 'пять', 'раз', 'интереснее', '2', 'почти', 'нет', 'философических', 'отступлений', '3', 'в', 'сто', 'раз', 'легче', 'читать', 'весь', 'французский', 'текст', 'заменен', 'русским', 'в', 'переводе', 'самого', 'толстого', '4', 'гораздо', 'больше', 'мира', 'и', 'меньше', 'войны', '5', 'хеппи-энд', 'эти', 'слова', 'я', 'поместил', 'семь', 'лет', 'назад', 'на', 'обложку', 'предыдущего', 'издания', 'указав', 'в', 'аннотации', 'первая', 'полная', 'редакция', 'великого', 'романа', 'созданная', 'к', 'концу', '1866', 'года', 'до', 'того', 'как', 'толстой', 'переделал', 'его', 'в', '1867--1869', 'годах', '--', 'и', 'что', 'я', 'использовал', 'такие-то', 'публикации', 'думая', 'что', 'все', 'всё', 'знают', 'я', 'не', 'объяснил', 'откуда', 'взялась', 'эта', 'первая', 'редакция', 'я', 'оказался', 'неправ', 'и', 'в', 'результате', 'оголтелые', 'и']

chapter_data[15][100]
# 'в'

# Подсчитаем, сколько раз каждое слово встречается в каждой из глав
# Инициализируем список, в котором будем хранить словари
chapter_words_count = []

# Создаем цикл по элементам внешнего списка со словами
for chapter_words in chapter_data:
    # Инициализируем пустой словарь, куда будем добавлять результаты
    temp = {}
    # Создаем цикл по элементам внутреннего списка
    for word in chapter_words:
        # Проверяем, что текущего слова еще нет в словаре
        if word not in temp:
            # Если условие выполняется, добавляем ключ в словарь
            temp[word] = 1
        else:
            # В противном случае, увеличиваем количество влождений слова в главу
            temp[word] += 1
    # Добавляем получившийся словарь в список
    chapter_words_count.append(temp)
# Выводим результат
#print(chapter_words_count)

chapter_words_count[15]['князю']
# ВыВодим: 2

# Создаем цикл по ключам словаря - спискам слов и их порядковым номерам
for chapter_number, chapter_dict in enumerate(chapter_words_count):
    # Выводим только первые 5 глав
    if chapter_number == 5:
        break
    # Выводим номер главы
    #print('-' * 40)
    #print('Chapter: {}'.format(chapter_number))
    #print('-' * 40)
    # Создаем цикл по ключам - словам и их порядковым номерам
    for j, word in enumerate(chapter_dict):
        # Выводим первые 10 слов из главы
        if j == 10:
            break
        #print(word, chapter_dict[word])
# Получаем ----------------------------------------
#Chapter: 0
#----------------------------------------
#1 1
#в 37
#два 3
#раза 1
#короче 1
#и 34
#пять 1
#раз 2
#интереснее 1
#2 1
#----------------------------------------
#Chapter: 1
#----------------------------------------
#автора 1
#я 20
#пишу 2
#до 1
#сих 1
#пор 1
#только 5
#о 2
#князьях 1
#графах 1
#----------------------------------------
#Chapter: 2
#----------------------------------------
#первая 1
#----------------------------------------
#Chapter: 3
#----------------------------------------
#-- 81
#ну 5
#что 44
#князь 21
#генуя 1
#и 94
#лукка 1
#стали 1
#не 57
#больше 2
#----------------------------------------
#Chapter: 4
#----------------------------------------
#гостиная 1
#анны 2
#павловны 2
#начала 1
#понемногу 1
#наполняться 1
#приехала 3
#высшая 1
#знать 1
#петербурга 2
```
```py
#создание своих функций
def first_function():
    print("Hello world!")
first_function()
first_function()
```
```
Создадим функцию, принимающую на вход один аргумент. 
Пусть функция принимает на вход время в минутах и печатает
 соответствующее этому числу минут целое число часов и остаток минут.
```
```py
def print_hours(minutes):
    # // — это оператор целочисленного деления
    hours = minutes // 60
    # % — это оператор получения остатка от деления
    left_minutes = minutes % 60
    print("Hours:", hours)
    print("Minutes left:", left_minutes)
    
print_hours(90)
```
```
Оператор, который позволяет функции передать какой-либо 
объект (число, строку, список, даже другую функцию) в то место
 кода, откуда вызывалась функция, называется return 
 (от англ. "return" — «возвращать»). При этом говорят, что функция
  возвращает какой-либо результат.
```
```py
# Назовём функцию get_time (get — получать,
# time — время). Она принимает аргументы
# distance — расстояние и speed — скорость.
def get_time(distance, speed):
    # В переменную result сохраним результат
    # деления расстояния на скорость.
    result = distance / speed

    # Чтобы вернуть результат вычислений,
    # пишем оператор return и название переменной,
    # значение которой будет передано.
    return result

    ```